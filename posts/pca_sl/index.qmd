---
title: "PCA, Structured Latent: Equity"
author: "Tom Williams"
date: "2023-08-08"
categories: []
draft: false
execute:
  daemon: false
---

In this post, ...

## Setup

```{python}
#| echo: false
#| code-fold: true
#| code-summary: "Auto reload"
%load_ext autoreload
%autoreload 2
```

```{python}
#| echo: false
#| code-fold: true
#| code-summary: "Environment"
import os
import sys
import importlib
sys.path.append("C:/hc/src")
sys.path.append("C:/hc/rambling")
sys.path.append("C:/hc/xfactors/src")
sys.path.append("C:/hc/xtuples/src")
os.environ["MODULE"] = "c:/hc/src/"
```

```{python}
#| code-fold: false
#| code-summary: "Imports"
import numpy
import pandas
import jax
import jax.numpy

import xtuples as xt
import xfactors as xf

import hcbt.data.prices.int as prices
import hcbt.algos.universe.int as universe
import hcbt.algos.universe.configs as configs
```

### Data


```{python}
#| code-fold: false
#| code-summary: "Returns"
df_returns = prices.returns_df(
    xf.dates.y(2005),
    xf.dates.y(2023, m=4),
    indices=configs.INDICES,
) 
```

The returns are from bloomberg, and include all cash and non-cash adjustments (in production we have a separate internal ticker for the dividend stream from a given name, but that's a little over-complicated for our purposes here).

We'll also load the relevant index membership mapping tables for our universe:

```{python}
#| code-fold: false
#| code-summary: "Index Membership"
dfs_indices = universe.rolling_indices(
    xf.dates.y(2005),
    xf.dates.y(2023, m=4),
    indices=configs.INDICES,
)
df_universe = universe.index_union(dfs_indices)
```

```{python}
#| code-fold: false
#| code-summary: "Sector Membership"
dfs_sectors = universe.rolling_indices(
    xf.dates.y(2005),
    xf.dates.y(2023, m=4),
    sectors=configs.GICS_SECTORS,
)
```

Vanilla PCA doesn't accomodate missing data, so given a particular target date range, we'll filter to only those tickers within our universe for the entire period, as so:

```{python}
#| code-fold: false
#| code-summary: "Universe"
def in_universe(ticker, df, threshold = 1.):
    if ticker not in df.columns:
        return False
    return (
        df[ticker].sum() / len(df.index)
    ) >= threshold
```

Which we'll then wrap into a convenience function.

```{python}
#| code-fold: true
#| code-summary: "get_returns"
def get_returns(d_start, d_end, threshold=1.):
    tickers = xt.iTuple(df_returns.columns).filter(
        in_universe,
        df=xf.dfs.index_date_filter(df_universe, d_start, d_end),
        threshold=threshold,
    ).pipe(list) 
    return xf.dfs.index_date_filter(
        df_returns, d_start, d_end
    )[tickers].dropna()
```

### Model



### Results


### Interpretation


### Related posts