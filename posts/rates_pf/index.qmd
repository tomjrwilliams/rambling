---
title: "PCA: Rates"
author: "Tom Williams"
date: "2023-08-08"
categories: []
draft: false
execute:
  daemon: false
---

In this post, we 

## Setup

```{python}
#| echo: false
#| code-fold: true
#| code-summary: "Auto reload"
%load_ext autoreload
%autoreload 2
```

```{python}
#| echo: false
#| code-fold: true
#| code-summary: "Environment"
import os
import sys
import importlib
sys.path.append("C:/hc/rambling")
sys.path.append("C:/hc/xtuples/src")
sys.path.append("C:/hc/xfactors/src")
os.chdir("c:/hc/xfactors")
```

```{python}
#| code-fold: false
#| code-summary: "Imports"
import numpy
import pandas
import jax
import jax.numpy

import xtuples as xt
import xfactors as xf
```

### Data

```{python}
#| code-fold: false
#| code-summary: "Returns"
dfs_curves = xf.bt.data.curve_dfs(
    curves=xt.iTuple([
        "YCSW0023",
        "YCGT0025",
        "YCSW0045",
        "YCGT0016",
    ]),
    # .extend(
    #     xf.bt.data.curves.CORP_USD
    # ).extend(
    #     xf.bt.data.curves.CORP_EUR
    # ),
    dp="../xfactors/__local__/csvs"
)
dfs_curves = {
    curve: xf.utils.dfs.apply_na_threshold(
        df, na_threshold=(0., 0.,), na_padding=(0.2, 0.4,)
    )
    for curve, df in dfs_curves.items()
}
```


```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
def curve_chart(d_start, d_end, curve):
    df = dfs_curves[curve]
    df = xf.utils.dfs.index_date_filter(df, date_start=d_start, date_end=d_end)
    df = xf.bt.data.enumerate_strip_curve(df, curve, reverse=True)
    return xf.visuals.graphs.df_line_chart(
        xf.utils.dfs.melt_with_index(df, index_as="date", variable_as="tenor"),
        x="date",
        y="value",
        color="tenor",
        discrete_color_scale="Blues",
    )
```

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
def tenor_chart(d_start, d_end, tenor, curves):
    df = xf.bt.data.curves_by_tenor({
        curve: df for curve, df in dfs_curves.items() if curve in curves
    }, tenor = tenor)
    df = xf.utils.dfs.index_date_filter(df, date_start=d_start, date_end=d_end)
    df = xf.bt.data.enumerate_strip_tenor(df, tenor, reverse=True)
    return xf.visuals.graphs.df_line_chart(
        xf.utils.dfs.melt_with_index(df, index_as="date", variable_as="curve"),
        x="date",
        y="value",
        color="curve",
        discrete_color_scale="Blues",
    )
```

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
import functools
# @functools.lru_cache(maxsize=10)
def fit_pca_kernel3(curve, d_start, d_end, n = 3):
    df = dfs_curves[curve]
    df = xf.utils.dfs.index_date_filter(df, date_start=d_start, date_end=d_end)

    data = (df,)

    n_kernels = 3
    n_factors = n
    
    N_STAGES = 7

    model, STAGES = xf.Model().init_stages(N_STAGES)
    INPUTS, SETUP, PARAMS, FACTORS, KERNELS, KERNEL_AGG, ENCODE, DECODE = STAGES

    model = (
        model.add_input(xf.nodes.inputs.dfs.Input_DataFrame_Wide(
            allow_missing_columns=True,
            allow_missing_indices=False,
            allow_new_columns=True,
            allow_new_indices=False,
            na_threshold_columns=0.,
            na_threshold_indices=0.,
        ))
        .add_input(xf.nodes.inputs.nds.Input_NDArray(
            numpy.linspace(0, 1, len(df.columns))
        ))
        .add_node(SETUP, xf.nodes.cov.vanilla.Cov(
            data=xf.Loc.result(INPUTS, 0),
        ), static = True)
        .pipe(xf.nodes.transforms.scaling.Logistic.add_to_model(
            SCALING, PARAMS=PARAMS
        ))
        .pipe(xf.nodes.transforms.scaling.Logistic.add_to_model(
            SCALING, PARAMS=PARAMS
        ))
        .pipe(lambda m: m.add_node(
            FACTORS,
            xf.nodes.scaling.scalar.Linear1D(
                a=xf.Loc.result(SCALING)
                data=xf.Loc.result(INPUTS, 0),
            
            # change to gaussian?

            # logistic is similarly a bell curve
            # so the idea here is we shift the origin slightly to the right
            # and scale so as to slope fairly gradually
        ))
        .add_node(FACTORS, xf.nodes.TBC(
            # slope could be 
            # two gaussians
            # one *-1 (presumably left negated, so upward slope)
            # where generally the first is shifted such that the peak is outside of range
            # but it can shift in (eg. 2010-2015 when front end was anchored, so level moves were further out in the curve)
            # so where they meet, zero out, at the level zero crossing point
        ))
        .add_node(FACTORS, xf.nodes.TBC(
            # arguably simplest is then just three gaussians?
            # for curvature
            # pos, neg, pos (if long short long)
        ))
        # NOTE: then look at parameter tying of eg. the shift
        # between (say) the level and the curvature (though not necessarily: see 10-15)
        
        # NOTE: then extend into grid of tenor vs rating
        # same gaussian basis functions, with perhaps some flattening / constraint
        # try various combinations of which factor (s) are given which tenor / rating

        # NOTE: the ideal is that we can interpret the shift parameters in time terms
        # so they can be even mapped against economic calendars
        # and / or at least interpreted in terms of specific calendar locations
    )

    model = model.init(data).optimise(
        data,
        iters = 5000,
        rand_init=10, 
        max_error_unchanged=0.5,
    )
    results = model.apply(data)

    params = model.params[PARAMS]

    # assumes centering?

    cov = results[KERNEL_AGG][0]
    
    # weights = params[3]
    # sigma = params[2]
    a = params[0]
    a2 = params[2]

    c = results[SCALING][0]
    c2 = results[SCALING][1]

    sigma=params[4]
    sigma2=params[5]

    print(a, a2)
    print(c, c2)
    print(sigma, sigma2)

    return df, cov
```

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
def plot_kernel3_cov(curve, d_start, d_end):
    df, cov = fit_pca_kernel3(curve, d_start, d_end)
    return xf.visuals.rendering.render_df_color_range(
        pandas.DataFrame(
            cov,
            index=df.columns,
            columns=df.columns,
        ),
        # v_min=-1.,
        # v_max=.1,
    )
```