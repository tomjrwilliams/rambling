---
title: "Example: PCA, Equity Returns"
author: "Tom Williams"
date: "2023-07-17"
categories: []
draft: false
---

I'm currently working on open-sourcing some of the factor decomposition utilities that I use in my day-job.

This post is a first simple example of how to use said utilities to do a PCA of some close-to-close equity returns.

## Setup

```{python}
#| code-fold: true
#| code-summary: "Environment"
import os
import sys
import importlib
sys.path.append("C:/hc/src")
os.environ["MODULE"] = "c:/hc/src/"
```

```{python}
#| code-fold: true
#| code-summary: "Imports - stdlib"
import datetime
import functools
import itertools
import numpy
import pandas
import jax
```

```{python}
#| code-fold: true
#| code-summary: "Imports - factors"
import core
importlib.reload(core)
import bt.data.prices.int
core.import_from_file("xtuples", "C:/hc/xtuples/src/xtuples/__init__.py")
core.import_from_file("xtenors", "C:/hc/xtenors/src/xtenors/__init__.py")
core.import_from_file("xfactors", "C:/hc/xfactors/src/xfactors/__init__.py")
```

##  Data

Our universe will be constituents of major european national equity indices

```{python}
#| code-fold: true
#| code-summary: "Data"
date_start = datetime.date(2005, 1, 1)
date_end = datetime.date(2023, 4, 1)
df_universe = ...
df_returns = bt.data.prices.int.returns_df(
    date_start,
    date_end,
    indices=core.Array(["SX5E Index"]),
) 
```

Which we'll filter to subset of our universe (those not added or removed from index in period)

```{python}
#| code-fold: true
#| code-summary: "Data"
def get_universe_returns():
    return
```

## Model

Take matrix of (n_tickers, n_dates)

Returns

Weight matrix of (n_tickers, n_factors)
Eigenvalues (n_factors)
Factors (n_factors, n_dates)

```{python}
#| code-fold: true
#| code-summary: "PCA"

```

Where mat mul: (re-compose)

```{python}
#| code-fold: true
#| code-summary: "PCA"

```

This is why we first filtered, doesn't take nan, tickers are columns so has to be fixed.

Model the factors as gaussian draws

```{python}
#| code-fold: true
#| code-summary: ""

```

Scaled up by the eigenvalue

```{python}
#| code-fold: true
#| code-summary: ""

```

And the weight matrix are orthogonal to one another

```{python}
#| code-fold: true
#| code-summary: ""

```

## Results

log transform?

The factors themselves are composite portfolios, and the return attributable to that factor that date.

Interpreting however, is a little difficult, very large weight vector:

```{python}
#| code-fold: true
#| code-summary: ""

```

We could try re-weighting back against industries.

For instance, normalise and then sum weight per industry from ticker:

```{python}
#| code-fold: true
#| code-summary: ""

```

But, some industries are overrpresented (below is proportion of universe per industry)

```{python}
#| code-fold: true
#| code-summary: ""

```

So have to divide by the proportion in the whole:

```{python}
#| code-fold: true
#| code-summary: ""

```

same by country

## Interpretation

We can see ..

Re run for other interesting time periods to show how most improtant driver changes over time

However, not so useful because

## Next Steps

Robust pca (gradient descent)

Then, stepping stone onto instrumented weights on one-hot industry