
```{python}
#| code-fold: false
#| code-summary: "Returns"
dfs_curves = xf.bt.data.curve_dfs(
    curves=xt.iTuple([
        "YCSW0023",
        "YCGT0025",
        "YCSW0045",
        "YCGT0016",
    ]).extend(
        xf.bt.data.curves.CORP_USD
    ).extend(
        xf.bt.data.curves.CORP_EUR
    ),
    dp="../xfactors/__local__/csvs"
)
dfs_curves = {
    curve: xf.utils.dfs.apply_na_threshold(
        df, na_threshold=(0., 0.,), na_padding=(0.2, 0.4,)
    )
    for curve, df in dfs_curves.items()
}
```

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
def tenor_chart(d_start, d_end, tenor, curves):
    df = xf.bt.data.curves_by_tenor({
        curve: df for curve, df in dfs_curves.items() if curve in curves
    }, tenor = tenor)
    df = xf.utils.dfs.index_date_filter(df, date_start=d_start, date_end=d_end)
    df = xf.bt.data.enumerate_strip_tenor(df, tenor, reverse=True)
    return xf.visuals.graphs.df_line_chart(
        xf.utils.dfs.melt_with_index(df, index_as="date", variable_as="curve"),
        x="date",
        y="value",
        color="curve",
        discrete_color_scale="Blues",
    )
```


```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
tenor_chart(
    xf.utils.dates.y(2005),
    xf.utils.dates.y(2023),
    curves=xt.iTuple.from_keys(dfs_curves).filter(lambda s: "USD" in s),
    tenor="3M",
)
```


```{python}
#| code-fold: false
#| code-summary: "PCA Factor Corr"
def curve_cov(curve, d_start, d_end):
    df = dfs_curves[curve]
    df = xf.utils.dfs.index_date_filter(
        df, date_start=d_start, date_end=d_end
    )
    return xf.visuals.rendering.render_df_color_range(
        df.cov(),
    )
curve_cov("USD-S", xf.utils.dates.y(2005), xf.utils.dates.y(2023))
```


As one can see, yields per tenor are pretty highly correlated across a given curve.

```{python}
#| code-fold: false
#| code-summary: "PCA Factor Corr"
def curve_corr(curve, d_start, d_end):
    df = dfs_curves[curve]
    df = xf.utils.dfs.index_date_filter(
        df, date_start=d_start, date_end=d_end
    )
    return xf.visuals.rendering.render_df_color_range(
        df.corr(),
        v_min=-1.,
        v_max=.1,
    )
curve_corr("USD-S", xf.utils.dates.y(2005), xf.utils.dates.y(2023))
```

As the weight matrix is orthonormal, it's (approximate) inverse is simply given by it's transpose (see the post [here](../orthogonal) for more detail).

As such, we can map our yield curve don to our factors by matrix multiplication with our weights, and then back up from ou

