---
title: "Rates: PCA"
author: "Tom Williams"
date: "2023-08-08"
categories: []
draft: false
execute:
  daemon: false
---

In this post, I'll demonstrate how to use PCA to extract a set of yield curve factors from historic market data.

I'll then provide an intuitive interpretation for the factors in terms of the level, slope, and curvature of the yield curve through time.

I'll conclude with some examples of how the shape of the factors themselves vary through time, and the implications of this w.r.t. next steps.

### Setup

```{python}
#| echo: false
#| code-fold: true
#| code-summary: "Auto reload"
%load_ext autoreload
%autoreload 2
```

```{python}
#| echo: false
#| code-fold: true
#| code-summary: "Environment"
import os
import sys
import importlib
sys.path.append("C:/rambling")
sys.path.append("C:/xfactors/src")
sys.path.append("C:/xtuples/src")
os.chdir("c:/xfactors")
```

```{python}
#| code-fold: false
#| code-summary: "Imports"
import numpy
import pandas
import jax
import jax.numpy

import xtuples as xt
import xfactors as xf
```

### Data

We'll start by loading some yield data for US and DE swap and bond curves.

```{python}
#| code-fold: true
#| code-summary: "Returns"
dfs_curves = xf.bt.data.curve_dfs(
    curves=xt.iTuple([
        "YCSW0023",
        "YCGT0025",
        "YCSW0045",
        "YCGT0016",
    ]),
    dp="../xfactors/__local__/csvs"
)
dfs_curves = {
    curve: xf.utils.dfs.apply_na_threshold(
        df, na_threshold=(0., 0.,), na_padding=(0.2, 0.4,)
    )
    for curve, df in dfs_curves.items()
}
```

Which we can plot as time series per tenor, as so:

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
def curve_chart(d_start, d_end, curve):
    df = dfs_curves[curve]
    df = xf.utils.dfs.index_date_filter(
        df, date_start=d_start, date_end=d_end
    )
    df = xf.bt.data.enumerate_strip_curve(df, curve, reverse=True)
    return xf.visuals.graphs.df_line_chart(
        xf.utils.dfs.melt_with_index(
            df, index_as="date", variable_as="tenor"
        ),
        x="date",
        y="value",
        color="tenor",
        discrete_color_scale="Blues",
    )
```

For example, US bond yields back to 2005:

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
curve_chart(xf.utils.dates.y(2005), xf.utils.dates.y(2023), "USD-G")
```

And US swap yields for the same time frame:

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
curve_chart(xf.utils.dates.y(2005), xf.utils.dates.y(2023), "USD-S")
```

As you can see, we have significantly more tenors available in our swap curve.

### PCA

[PCA](../pca) decomposes a given data matrix into a matrix of orthonormal factor loadings, and a matrix of independent unit-gaussian factor embeddings (see the linked post for more detail).

There are roughly two ways to do this:

- Eigen-decomposition of the input data covariance matrix.
- Constrained minimisation of the re-constructed data matrix (following a round-trip encoding into factor space, and decoding back up into the original data space).

For now, we'll go with the first of these.

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
import functools
@functools.lru_cache(maxsize=10)
def fit_pca(curve, d_start, d_end, n):
    df = dfs_curves[curve]
    df = xf.utils.dfs.index_date_filter(df, date_start=d_start, date_end=d_end)
    eigvals, eigvecs = xf.nodes.pca.vanilla.PCA.f(
        jax.numpy.transpose(df.values), n = n
    )
    return df, eigvals.real, eigvecs.real
```

We can plot the resulting factor loadings as bar charts.

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
def pca_weights_chart(curve, d_start, d_end, n):
    df, eigvals, eigvecs = fit_pca(curve, d_start, d_end, n)
    weights = pandas.DataFrame(
        eigvecs.T,
        columns=df.columns,
        index=list(range(eigvals.shape[0]))
    )
    return xf.visuals.graphs.df_facet_bar_chart(
        xf.utils.dfs.melt_with_index(weights, index_as="factor"),
        x="variable",
        y="value",
        facet="factor",
        title="{}: {} - {}".format(curve, d_start, d_end)
    )
```

And the resulting embeddings as time series, in a similar form to the above.

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
def pca_path_chart(curve, d_start, d_end, n):
    df, eigvals, eigvecs = fit_pca(curve, d_start, d_end, n)
    factors = jax.numpy.matmul(df.values, eigvecs)
    factors_df = pandas.DataFrame(
        factors,
        columns=list(range(eigvals.shape[0])),
        index=df.index,
    )
    return xf.visuals.graphs.df_facet_line_chart(
        xf.utils.dfs.melt_with_index(factors_df, index_as="date"),
        x="date",
        y="value",
        facet="variable",
        title="{}: {} - {}".format(curve, d_start, d_end)
    )
```

### Factors

For instance, below are the first three factors extracted from a history of the USD swap curve spanning from 2005 through to April 2023:

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
pca_weights_chart("USD-S", xf.utils.dates.y(2005), xf.utils.dates.y(2023), 3)
```

As one can see, there is a clear structure to the three components.

The first 'level' component - capturing the majority of the variance of our yield curve - has loadings with all the same sign, downward sloping from a peak amongst the first few tenors, and is conventionally positive.

The second component slopes (roughly) monotonically from one sign to another (conventionally from negative to positive), with a single zero point, and is known as the 'slope' factor.

The third has two zero points, with the front- and back-end of the curve weighted counter to the belly, and is referred to as the 'curvature'.

As one can see, we get a very similar result from the USD bond curve:

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
pca_weights_chart("USD-G", xf.utils.dates.y(2005), xf.utils.dates.y(2023), 3)
```

### Discussion

Where things get particularly interesting is if we run the same decomposition on particular sub-sets of our yield history.

For instance, on our swap curve, but between only 2010 and 2015:

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
pca_weights_chart("USD-S", xf.utils.dates.y(2010), xf.utils.dates.y(2015), 3)
```

As one can see, the shape of level component has both almost entirely inverted, and has more or completely flattened at the front end.

Furthermore, our slope component is no longer monotonic, having developed a peak of it's own around the 18 month point.

We get a similar result from the bond curve:

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
pca_weights_chart("USD-G", xf.utils.dates.y(2010), xf.utils.dates.y(2015), 3)
```

Though, here, the level component is even slightly negative at the front-end.

These loadings do make some sense: during this period fed rates were firmly anchored at the zero lower bound, so there was relatively little market volatility in front-end rates.

You can see this if you scroll back up to the yield curve time series above (observe the first few tenors pinned close to zero).

As such, the first two components - each of which simply captures co-variation in yields - have very small loadings on the front end (as these tenors simply didn't move very much during this period).

We also see something very similar in the EUR swaps factors for 2017 through 2019:

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
pca_weights_chart("EUR-S", xf.utils.dates.y(2017), xf.utils.dates.y(2019), 3)
```

Which, again, makes sense if you refer back to the relevant period in the yield curve history:

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
curve_chart(xf.utils.dates.y(2005), xf.utils.dates.y(2023), "EUR-S")
```

And, to some extent, in the German government bond curve from 2012 to 2016:

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
pca_weights_chart("EUR-DE", xf.utils.dates.y(2012), xf.utils.dates.y(2016), 3)
```

Which, again, makes sense given the relative volatility of the front and long end of the curve during this period:

```{python}
#| code-fold: true
#| code-summary: "Sector Weights Chart"
curve_chart(xf.utils.dates.y(2005), xf.utils.dates.y(2023), "EUR-DE")
```

### Conclusion

These are, admitteldy, particularly striking examples of factor instability - coinciding as they did with periods of especially unusual central bank monetary policy.

That being said, it is nonetheless clear that, without further prior structure imposed on the shape of our components, the factors extracted by PCA can vary significantly through time.

Whilst the variation is clearly less than that observed from equivalent analysis in [equity markets](../equity_pca), it is just as clearly worthy of both quantification, and further study.

For instance, if the goal is to use the factors above as part of a forward-looking forecasting model, then an optimal model would likely not just be able to forecast the factor paths, but also their changing composition, over time.